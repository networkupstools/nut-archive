:titles.underlines: "__","==","--","~~","^^"

Eaton Software Development Kit
______________________________
:Author: Frederic_Bohe
:Author Initials: FB

Introduction
============

The Eaton Software Development Kit (“SDK”) allows your applications to connect
to certain Eaton devices and retrieve certain internal data. Eaton SDK
extensively uses the link:http://www.networkupstools.org[NUT - Network UPS Tools]
Opensource framework (supported by Eaton), to do so.

WARNING: This version of Eaton SDK is tagged Beta, and is currently only
intended for evaluation purpose.

This document provides the documentation for using the Eaton SDK libraries
integration, on Linux and Microsoft Windows platforms, in <<SDK,chapter 3>>.

In case using the SDK libraries is not possible in your project (refer e.g. to
the <<Legal, Legal limitations>> and <<SDK_limitation,SDK limitation>>), you
will find alternatives methods on using the NUT framework with your application
in the following chapters:

- <<Full_framework,Chapter 4>> describes how to interact with the full NUT
framework,
- <<Partial_framework,Chapter 5>> explains how to use directly NUT
drivers,
- <<Reimplementation,Chapter 6>> contains some hints on how to
re-implement the device specific protocol.


[[Legal]]

Legal limitations
=================

The Network UPS Tools Opensource framework is a GNU General Public License (GPL)
software that provides support for many different UPSs and PDUs. We expressly
make the license terms of the GNU GPL applicable to this SDK solution, and by
using the SDK you also accept to abide by these license terms; please see below. 

GPL software have legal and technical implications, and generally can not be
used with proprietary software. You should consider these very seriously before
making a choice and using the present SDK.

WARNING: Eaton recommends to use this SDK or the other documented approaches
only as described in this document or the attached documentation. 
Eaton does not warrant completeness, correctness and permanent availability of
the data and information retrieved by using the SDK (unless required by
applicable law). Eaton does not assume any liability (unless required by
applicable law), for damages resulting from the use of the SDK, or data or
information retrieved by using SDK. 

Here are some references that may help you understand these limitations and
constraints: link:http://www.gnu.org/licenses/gpl-faq.html[GPL FAQ].

Please also respect the following notice, which is compulsory for using the GPL:

Copyright (C) 2011 - 2012 Eaton Industries France - Frédéric Bohe, Arnaud Quette

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>. 


Support information
===================

In case you become aware of any malfunctions of this solution, we kindly ask you
to inform us using the following support form:

link:http://pqtools.eaton.com/form/support/index_soft.php?lang=eng[http://pqtools.eaton.com/form/support/index_soft.php?lang=eng].

In this case, please use 'Eaton Open Source' as 'Software used', and mention
'Eaton SDK' in your message, with the details of your issue.

We recommend to only obtain this software from original Eaton sources, and to
check for updates regularly, so that you can enjoy the latest functionalities.


[[SDK]]

Eaton SDK
=========

NOTE: before using the Eaton SDK, please review secion 2 regarding legal limitations. If in doubt, 
chapter 2 references several documents to guide you through the licensing. <<Legal,chapter 2>>.

[[SDK_limitation]]
Limitation
----------

Using the Eaton SDK library approach, an application can only manage one device!
If you need to manage more than one device, please contact the Eaton Opensource
team, or refer to the other possible approaches detailed in other chapters of this 
user's guide as shown in the <<_introduction,Introduction>> chapter.

Please, also note that Eaton SDK is not yet Multi thread safe. Thus, you need
to pay attention to have at most one thread that call Eaton SDK functions.

How does it work?
-----------------

The SDK consists of several libraries allowing access to Eaton's UPS/PDU in
several ways. Your application may link to one of those libraries to access a
UPS/PDU.

To use this library, your application must initialize it first by calling
libeaton_init function.

--------------------------------------
void libeaton_init(char * device)
--------------------------------------

The device parameter depends on the library you are using and is discussed in
the relevant in following chapters.
You may want to fine tune your device (for SNMP configuration for exemple). In this case you must call libeaton_set_var BEFORE libeaton_init (see below).

Now you can call function to read or write variables of your device. You can
also request your device to execute instant commands.
Each of these functions gets the variable name or command name. A list of all existing
variables and commands can be found in <<nut-names,appendix A>>. Note that this
gives all existing variables and commands, not all available variables and
commands, which depend on the device type.

To have the list of available commands and variables of your device you can use
the libeaton_dump_all function.

To read a variable, use the libeaton_read function in conjunction with the
libeaton_update function:

--------------------------------------
void libeaton_update(void);
const char *libeaton_read(const char *varname)
--------------------------------------
libeaton_read returns a pointer to a string containing the value of the
variable or NULL if an error occurred.
It points to a string managed by the library you must not try to free it.
libeaton_read returns data which were gathered in the last call to
libeaton_update. It's up to your application to call  libeaton_update in
order to have fresh data (but remember this may be time consuming, especially
for serial connections).
You must call libeaton_update at least once before calling libeaton_read or
it will fail.

To write a variable, use the libeaton_write function:

--------------------------------------
int libeaton_write (const char *varname, const char *val)
--------------------------------------
libeaton_write returns 0 if the variable was successfully written.

To call an instant command, use the libeaton_command function:

--------------------------------------
int libeaton_command(const char *cmdname, const char *extradata)
--------------------------------------
libeaton_command return 0 if the command was successfully issued.

To list available commands and variables:

--------------------------------------
char * libeaton_dump_all()
--------------------------------------
libeaton_dump_all returns a pointer to a buffer containing the available commands and variables for the current device.
This list contains several lines in the form :

type<tab>command or variable name<tab>value<CR>or<EOF>

    * type is one of VAR_RO, VAR_RW or CMD
    * value is only available for variable

This is a sample output:

--------------------------------------
VAR_RO	ups.mfr	Eaton
VAR_RW	outlet.1.delay.shutdown	10
CMD	outlet.1.shutdown.return
--------------------------------------

You may want to fine tune the behavior of the SDK. For this, you can use:

--------------------------------------
int libeaton_set_var(const char *var, char *val)
--------------------------------------

This allows to set a specific SDK variable to a given value.
THIS MUST BE CALLED BEFORE libeaton_init !
This is especially useful for SNMP v1 community and SNMP v3 configuration.
The list of available variable can be obtained with a call to:

--------------------------------------
const char * libeaton_dump_var(void)
--------------------------------------

This returns a buffer containing severals lines in the form :

type<tab>variable name<tab>variable description<CR>or<EOF>

    * type is one of VAR_VALUE or VAR_FLAG

This is a sample output:

--------------------------------------
VAR_VALUE	community	Set community name (default=public)
VAR_FLAG	notransferoids	Disable transfer OIDs
--------------------------------------

Once done with your device you should call libeaton_free function to free
internal data.

--------------------------------------
void libeaton_free()
--------------------------------------

This is for debugging and support purpose :

--------------------------------------
int libeaton_debug_level
--------------------------------------
You can set this variable to a value from 1 to 5 for more or less verbosity of
the library (0 is no debug output).
If you ask for support you will probably be asked to set this variable to a
value of 3 or above.


Building your application with the SDK
--------------------------------------

For all environments and all type of connections, you need all of the following
files available in your include path: attribute.h, common.h, config.h,
libeaton.h, proto.h and timehead.h. You may need to add the -I<path-to-include>
option to the build command lines provided in this document to point to those
header files.

You may have to link with libeaton shared libraries. To do so the relevant
libeaton shared library must be available for your compiler. So you have 
to add the correct "-L <path-to-library>" to the build command lines provided in
this document to point to those libraries.

Depending the type of connection, you may need additional external libraries
(net-snmp, neon...) which are described in the relevant chapter. 

Linux build
~~~~~~~~~~~

On Linux, building with the SDK has been tested using GCC. +
For static link you will need the corresponding ``.a'' file. +
For dynamic link you will need the corresponding ``.so'' file for compilation 
and ``.so'', ``.so.0'' and ``.so.0.0.0'' in you libs path for execution.

For dynamic link, you will also need to point the system linker at
Eaton SDK library. To do so, just use the environment variable
'LD_LIBRARY_PATH' the following way:

	$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/eaton_so_libraries

For example, if Eaton SDK dynamic libraries reside in /opt/eaton/lib, use:

	$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/eaton/lib


Windows build
~~~~~~~~~~~~~

On Windows, building with the SDK has been tested with GCC 4.6.1 in MinGW
environment and CL in MS Visual Studio 10 environment. +
You will need GCC 4.6.1 or newer to compile your application with the SDK.

Building SNMP application
-------------------------

You must call libeaton_init with your device's IP.

This is a sample code displaying the device status:

--------------------------------------
#include "common.h"
#include "libeaton.h"

int main(void)
{
        /* This contains the result of our request to the device */
        const char * status;

        /* init the library */
        libeaton_init("192.168.0.17");

        /* This is the real request to the device to update internal database.
        This may be time consuming */
        libeaton_update();

        /* Here we get the status of the device from the database */
        status = libeaton_read("ups.status");

        printf("%s\n",status);

        /* Free SDK internals */
        libeaton_free();

        exit(EXIT_SUCCESS);
}
--------------------------------------

Save this code in the file test.c

Linux build
~~~~~~~~~~~

You need link:http://www.net-snmp.org/download.html[net-snmp library] available
on your system.
Make sure “net-snmp-config” command is available.
Building statically:

--------------------------------------
gcc test.c -I<path-to-include> <path-to-lib>/libeaton_snmp.a `net-snmp-config --base-lib-cflags --libs` -o test
--------------------------------------

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> -L <path-to-lib> -leaton_snmp `net-snmp-config --base-lib-cflags --libs` -o test
--------------------------------------

Windows build
~~~~~~~~~~~~~

With MSVC
^^^^^^^^^

You will need the libeaton_snmp.lib file. This is how to create it from
libeaton_snmp-0.dll.

--------------------------------------
pexports libeaton_snmp-0.dll > libeaton_snmp.def
lib /machine:i386 /def:libeaton_snmp.def
--------------------------------------

Then you can link it to your application.

--------------------------------------
cl test.c -DWIN32 libeaton_snmp.lib
--------------------------------------

You need libnetsnmp-30.dll, libregex-1.dll and libeaton_snmp-0.dll
in your path to run the resulting executable.

With MinGW
^^^^^^^^^^

Building statically:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_snmp.a libnetsnmp.a libregex.a -lws2_32
--------------------------------------

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_snmp.dll.a libcommon.dll.a
--------------------------------------

You need libnetsnmp-30.dll, libregex-1.dll and  libeaton_snmp-0.dll
in your path to run the resulting executable.

Building XML/HTTP application
-----------------------------

You must call libeaton_init with your device's URL.

This is a sample code displaying the device status:

--------------------------------------
#include "common.h"
#include "libeaton.h"

int main(void)
{
        /* This will contain the result of our request to the device */
        const char * status;

        /* init the library */
        libeaton_init("http://192.168.0.17");

        /* This is the real request to the device to update internal database.
        This may be time consuming */
        libeaton_update();

        /* Here we get the status of the device from the database */
        status = libeaton_read("ups.status");

        printf("%s\n",status);

        /* Free SDK internals */
        libeaton_free();

        exit(EXIT_SUCCESS);
}
--------------------------------------

Save this code in the file test.c

Linux build
~~~~~~~~~~~

You need link:http://www.webdav.org/neon/[neon library] available on your
system.
Make sure “pkg-config neon” command is available.

Building statically:

--------------------------------------
gcc test.c -I<path-to-include> <path-to-lib>/libeaton_xmlpdc.a `pkg-config --cflags --libs neon` -o test
--------------------------------------

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> -L <path-to-lib> -leaton_xmlpdc `pkg-config --cflags --libs neon` -o test
--------------------------------------

Windows build
~~~~~~~~~~~~~

With MSVC
^^^^^^^^^

You will need the libeaton_xmlpdc.lib file. This is how to create it from
libeaton_xmlpdc-0.dll.

--------------------------------------
pexports libeaton_xmlpdc-0.dll > libeaton_xmlpdc.def
lib /machine:i386 /def:libeaton_xmlpdc.def
--------------------------------------

Then you can link it to your application.

--------------------------------------
cl test.c -DWIN32 libeaton_xmlpdc.lib
--------------------------------------

You need libneon-27.dll,  libeaton_xmlpdc-0.dll, libexpat-1.dll, libiconv-2.dll,
libintl-8.dll and libz-1.dll in your path to run the resulting executable.

With MinGW
^^^^^^^^^^

Building statically:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_xmlpdc.a libneon.a libintl.a libexpat.a libiconv.a -lws2_32
--------------------------------------

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_xmlpdc.dll.a
--------------------------------------

You need libneon-27.dll,  libeaton_xmlpdc-0.dll, libexpat-1.dll, libiconv-2.dll,
libintl-8.dll and libz-1.dll in your path to run the resulting executable.

Building USB HID application
----------------------------

You must call libeaton_init with NULL as a parameter.

This is a sample code displaying the device status:

--------------------------------------
#include "common.h"
#include "libeaton.h"

int main(void)
{
        /* This will contain the result of our request to the device */
        const char * status;

        /* init the library */
        libeaton_init(NULL);

        /* This is the real request to the device to update internal database.
        This may be time consuming */
        libeaton_update();

        /* Here we get the status of the device from the database */
        status = libeaton_read("ups.status");

        printf("%s\n",status);

        /* Free SDK internals */
        libeaton_free();

        exit(EXIT_SUCCESS);
}
--------------------------------------

Save this code in the file test.c

Linux build
~~~~~~~~~~~

You need link:http://www.libusb.org/[libusb library] available on your system.
Make sure “pkg-config libusb” command is available.
Building statically:

--------------------------------------
gcc test.c -I<path-to-include> <path-to-lib>/libeaton_usbhid.a `pkg-config --cflags --libs libusb` -o test
--------------------------------------

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> -L <path-to-lib> -leaton_usbhid `pkg-config --cflags --libs libusb` -o test
--------------------------------------

Windows build
~~~~~~~~~~~~~

You must install a libusb driver for your device. You can either install the
device driver (NOT the filter driver) from the official
link:http://www.libusb.org/wiki/libusb-win32[libusb-win32 binaries] or use the
wdi-simple.exe of the
link:http://www.networkupstools.org/download.html[NUT Windows' package] which
install it automatically.

With MSVC
^^^^^^^^^

You will need the libeaton_usbhid.lib file. This is how to create it from
libeaton_usbhid-0.dll.

--------------------------------------
pexports libeaton_usbhid-0.dll > libeaton_usbhid.def
lib /machine:i386 /def:libeaton_usbhid.def
--------------------------------------

Then you can link it to your application.

--------------------------------------
cl test.c -DWIN32 libeaton_usbhid.lib
--------------------------------------

You need libeaton_usbhid-0.dll, libregex-1.dll and libusb0.dll 
in your path to run the resulting executable.

With MinGW
^^^^^^^^^^

Building statically:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_usbhid.a libusb.a libgnu.a -lws2_32
--------------------------------------

You need libusb0.dll in your path to run the resulting executable.

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_usbhid.dll.a
--------------------------------------

You need libeaton_usbhid-0.dll, libregex-1.dll and libusb0.dll
in your path to run the resulting executable.

Building USB XCP application
----------------------------

You must call libeaton_init with NULL as a parameter.

This is a sample code displaying the device status:

--------------------------------------
#include "common.h"
#include "libeaton.h"

int main(void)
{
        /* This will contains the result of our request to the device */
        const char * status;

        /* init the library */
        libeaton_init(NULL);

        /* This is the real request to the device to update internal database.
        This may be time consuming */
        libeaton_update();

        /* Here we get the status of the device from the database */
        status = libeaton_read("ups.status");

        printf("%s\n",status);

        /* Free SDK internals */
        libeaton_free();

        exit(EXIT_SUCCESS);
}
--------------------------------------

Save this code in the file test.c

Linux build
~~~~~~~~~~~

You need link:http://www.libusb.org/[libusb library] available on your system.
Make sure “pkg-config libusb” command is available.
Building statically:

--------------------------------------
gcc test.c -I<path-to-include> <path-to-lib>/libeaton_usbxcp.a `pkg-config --cflags --libs libusb` -o test
--------------------------------------

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> -L <path-to-lib> -leaton_usbxcp `pkg-config --cflags --libs libusb` -o test
--------------------------------------

Windows build
~~~~~~~~~~~~~

You must install a libusb driver for your device. You can either install the
device driver (NOT the filter driver) from the official
link:http://www.libusb.org/wiki/libusb-win32[libusb-win32 binaries] or use the
wdi-simple.exe of the
link:http://www.networkupstools.org/download.html[NUT Windows' package] which
install it automatically.

With MSVC
^^^^^^^^^

You will need the libeaton_usbxcp.lib file. This is how to create it from
libeaton_usbxcp-0.dll.

--------------------------------------
pexports libeaton_usbxcp-0.dll > libeaton_usbxcp.def
lib /machine:i386 /def:libeaton_usbxcp.def
--------------------------------------

Then you can link it to your application.

--------------------------------------
cl test.c -DWIN32 libeaton_usbxcp.lib
--------------------------------------

You need libeaton_usbxcp-0.dll, libregex-1.dll and libusb0.dll
in your path to run the resulting executable.

With MinGW
^^^^^^^^^^

Building statically:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_usbxcp.a libusb.a libgnu.a -lws2_32
--------------------------------------

You need libusb0.dll in your path to run the resulting executable.

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_usbxcp.dll.a
--------------------------------------

You need libeaton_usbxcp-0.dll, libregex-1.dll and libusb0.dll
in your path to run the resulting executable.

Building USB blazer application
-------------------------------

You must call libeaton_init with NULL as a parameter.

This is a sample code displaying the device status:

--------------------------------------
#include "common.h"
#include "libeaton.h"

const char *dstate_getinfo(const char *var);

int main(void)
{
        /* This will contains the result of our request to the device */
        const char * status;

	/* Init battery charge estimation, based on a nominal battery voltage
	   = 12 V with the following formula
	   low_batt_voltage = 104 * nominal_batt_voltage / 120;
	   high_batt_voltage = 130 * nominal_batt_voltage / 120;

	   This may need to be adapted to your specific device
	 */
	dstate_setinfo("battery.voltage.low", "10.4");
	dstate_setinfo("battery.voltage.high", "13.0");

        /* init the library */
        libeaton_init(NULL);

        /* This is the real request to the device to update internal database.
        This may be time consuming */
        libeaton_update();

        /* Here we get the status of the device from the database */
        status = libeaton_read("ups.status");

        printf("%s\n",status);

        /* Free SDK internals */
        libeaton_free();

        exit(EXIT_SUCCESS);
}
--------------------------------------

Save this code in the file test.c

Note that the code involving the dstate_setinfo function is used to
guestimate the battery charge, since these devices do not give it directly.
If you do not need the battery charge, you don't need this additional code.

Linux build
~~~~~~~~~~~

You need link:http://www.libusb.org/[libusb library] available on your system.
Make sure “pkg-config libusb” command is available.
Building statically:

--------------------------------------
gcc test.c -I<path-to-include> <path-to-lib>/libeaton_usbblazer.a `pkg-config --cflags --libs libusb` -lm -o test
--------------------------------------

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> -L <path-to-lib> -leaton_usbblazer `pkg-config --cflags --libs libusb` -o test
--------------------------------------

Windows build
~~~~~~~~~~~~~

You must install a libusb driver for your device. You can either install the
device driver (NOT the filter driver) from the official
link:http://www.libusb.org/wiki/libusb-win32[libusb-win32 binaries] or use the
wdi-simple.exe of the
link:http://www.networkupstools.org/download.html[NUT Windows' package] which
install it automatically.

With MSVC
^^^^^^^^^

You will need the libeaton_usbblazer.lib file. This is how to create it from
libeaton_usbblazer-0.dll.

--------------------------------------
pexports libeaton_usbblazer-0.dll > libeaton_usbblazer.def
lib /machine:i386 /def:libeaton_usbblazer.def
--------------------------------------

Then you can link it to your application.

--------------------------------------
cl test.c -DWIN32 libeaton_usbblazer.lib
--------------------------------------

You need libeaton_usbblazer-0.dll, libregex-1.dll and libusb0.dll
in your path to run the resulting executable.

With MinGW
^^^^^^^^^^

Building statically:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_usbblazer.a libusb.a libgnu.a -lws2_32
--------------------------------------

You need libusb0.dll in your path to run the resulting
executable.

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_usbblazer.dll.a
--------------------------------------

You need libeaton_usbblazer-0.dll, libregex-1.dll and libusb0.dll
in your path to run the resulting executable.


Building serial XCP application
-------------------------------

You must call libeaton_init with the name of the serial port device.
On Linux, it is something like "/dev/ttyS0" or "/dev/ttyUSB0".
On windows, it is something like "COM1".

Note that the initialization phase may be very long (about 30 seconds).

This is a sample code displaying the device status:

--------------------------------------
#include "common.h"
#include "libeaton.h"

int main(void)
{
        /* This will contains the result of our request to the device */
        const char * status;

        /* init the library */
        libeaton_init("/dev/ttyS0");

        /* This is the real request to the device to update internal database.
        This may be time consuming */
        libeaton_update();

        /* Here we get the status of the device from the database */
        status = libeaton_read("ups.status");

        printf("%s\n",status);

        /* Free SDK internals */
        libeaton_free();

        exit(EXIT_SUCCESS);
}
--------------------------------------

Save this code in the file test.c

Linux build
~~~~~~~~~~~

Building statically:

--------------------------------------
gcc test.c -I<path-to-include> <path-to-lib>/libeaton_serialxcp.a -o test
--------------------------------------

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> -L <path-to-lib> -leaton_serialxcp -o test
--------------------------------------

Windows build
~~~~~~~~~~~~~

With MSVC
^^^^^^^^^

You will need the libeaton_serialxcp.lib file. This is how to create it from
libeaton_serialxcp-0.dll.

--------------------------------------
pexports libeaton_serialxcp-0.dll > libeaton_serialxcp.def
lib /machine:i386 /def:libeaton_serialxcp.def
--------------------------------------

Then you can link it to your application.

--------------------------------------
cl test.c -DWIN32 libeaton_serialxcp.lib
--------------------------------------

You need libeaton_serialxcp-0.dll in
your path to run the resulting executable.

With MinGW
^^^^^^^^^^

Building statically:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_serialxcp.a -lws2_32
--------------------------------------

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_serialxcp.dll.a
--------------------------------------

You need libeaton_serialxcp-0.dll in
your path to run the resulting executable.

Building SHUT application
-------------------------

You must call libeaton_init with the name of the serial port device.
On Linux, it is something like "/dev/ttyS0" or "/dev/ttyUSB0".
On windows, it is something like "COM1".

Note that the initialization phase may be very long (about 20 seconds).

This is a sample code displaying the device status:

--------------------------------------
#include "common.h"
#include "libeaton.h"

int main(void)
{
        /* This will contains the result of our request to the device */
        const char * status;

        /* init the library */
        libeaton_init("/dev/ttyS0");

        /* This is the real request to the device to update internal database.
        This may be time consuming */
        libeaton_update();

        /* Here we get the status of the device from the database */
        status = libeaton_read("ups.status");

        printf("%s\n",status);

        /* Free SDK internals */
        libeaton_free();

        exit(EXIT_SUCCESS);
}
--------------------------------------

Save this code in the file test.c

Linux build
~~~~~~~~~~~

Building statically:

--------------------------------------
gcc test.c -I<path-to-include> <path-to-lib>/libeaton_shut.a -o test
--------------------------------------

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> -L <path-to-lib> -leaton_shut -o test
--------------------------------------

Windows build
~~~~~~~~~~~~~

With MSVC
^^^^^^^^^

You will need the libeaton_shut.lib file. This is how to create it from
libeaton_shut-0.dll.

--------------------------------------
pexports libeaton_shut-0.dll > libeaton_shut.def
lib /machine:i386 /def:libeaton_shut.def
--------------------------------------

Then you can link it to your application.

--------------------------------------
cl test.c -DWIN32 libeaton_shut.lib
--------------------------------------

You need libeaton_shut-0.dll in your
path to run the resulting executable.

With MinGW
^^^^^^^^^^

Building statically:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_shut.a -lws2_32
--------------------------------------

Building with shared object:

--------------------------------------
gcc test.c -I<path-to-include> libeaton_shut.dll.a
--------------------------------------

You need libeaton_shut-0.dll in your path to run the resulting executable.

[[Full_framework]]

Using the complete NUT framework
================================

NOTE: This approach does not suffer the limitation of the 'library SDK', as
presented in the <<SDK_limitation,SDK limitation>> chapter!

The NUT framework basically consists in a server (upsd) connected to drivers
(which are themselves connected to device). Once this framework is running,
clients can access device data and send commands via the upsd server.

image:images/nut_layering.png[NUT architecture]

There is a number of client applications available with NUT (upsc, upsmon...),
which can serve as reference implementations. You can also write your own using
the upsclient library. This is discussed in the
link:http://www.networkupstools.org/docs/developer-guide.chunked/ar01s07.html[NUT documentation].

WARNING: NUT libupsclient is licensed under GNU GPL. Refer to the chapter
<<Legal, Legal limitations>> for more information.

As stated in the above link, if you can't use the upsclient library, you can
still directly access the nut server by implementing the 'client - server'
protocol which is documented
link:http://www.networkupstools.org/docs/developer-guide.chunked/ar01s08.html[here].


[[Partial_framework]]

Using part of the NUT framework
===============================

NOTE: This approach does not suffer the limitation of the 'library SDK', as
presented in the <<SDK_limitation,SDK limitation>> chapter!

As presented in the <<Full_framework,previous chapter>>, the NUT framework
consists of driver(s) connected to a server.

You may choose to not use the server and to connect directly to the driver. For
information on how to interface with the NUT drivers, refer to
link:http://www.networkupstools.org/docs/developer-guide.chunked/ar01s05.html[the protocol].

For a Linux minimalistic implementation of this method, you can also refer to
the
link:http://anonscm.debian.org/viewvc/nut/trunk/server/sockdebug.c?view=markup[server/sockdebug.c]
debug program, that can be found in the NUT sources.


[[Reimplementation]]

Protocol re-implementation
==========================

You may choose not to use NUT at all and directly re-implement the communication
protocol with the device. In this case you may find useful information
hereafter.

USB and shut
------------

Example of specific protocol reimplementation, for USB/HID with an Eaton
Protection Station



1) Get the data topology

Using the NUT - Network UPS Tools 'usbhid-ups' driver, launch it with debug
level 1:

--------------------------------------
$ /path/to/usbhid-ups -D -a <device name>

   2.632336	Using subdriver: MGE HID 1.27
   (...)
   3.432575	Path: UPS.PowerSummary.PresentStatus.ACPresent, Type: Feature, ReportID: 0x01, Offset: 0, Size: 1, Value: 1
   3.432618	Path: UPS.PowerSummary.PresentStatus.ACPresent, Type: Input, ReportID: 0x01, Offset: 0, Size: 1, Value: 1
   (...)
   3.569335	Path: UPS.PowerSummary.RunTimeToEmpty, Type: Feature, ReportID: 0x06, Offset: 8, Size: 32, Value: 1171
   3.569357	Path: UPS.PowerSummary.RunTimeToEmpty, Type: Input, ReportID: 0x06, Offset: 8, Size: 32, Value: 1171
   3.671941	Detected a UPS: EATON/Protection Station 650
--------------------------------------

The above is only a small excerpt of data provided by USB/HID devices.
It shows the various data that are available for a specific device, and how to
request these and extract the result.

You can then switch to debug level 3 (ie "-DDD") to see the raw USB frames:

--------------------------------------
$ /path/to/usbhid-ups -DDD -a <device name>

   2.623379	Using subdriver: MGE HID 1.27
   (...)
   3.425409	Report[get]: (4 bytes) => 01 25 00 00
   3.425454	Path: UPS.PowerSummary.PresentStatus.ACPresent, Type: Feature, ReportID: 0x01, Offset: 0, Size: 1, Value: 1
   (...)
--------------------------------------



2) Understand how to use these information

------------------
Report[get]: (4 bytes) => 01 25 00 00
------------------

This line means that the device send us 4 bytes. The first one is the ReportID
(here : 0x01), then we have 3 data bytes.

------------------
Path: UPS.PowerSummary.PresentStatus.ACPresent, Type: Feature, ReportID: 0x01, Offset: 0, Size: 1, Value: 1
------------------

This line is the interpretation of the above data by NUT. It says that it is the ReportID 0x01 and that at offset 0 (in bits) we have a data of size 1 (in bits)
with a value of 1 (0x25 = 00100101).
This data HID path is
UPS.PowerSummary.PresentStatus.ACPresent. This means that this device is on-line
.
"Type: Feature" means that this data is a "status" data which is fetched by the
application.
On the contrary you can have "Type: Input" which are "events" sent
asynchronously by the UPS. This tutorial will focus on "Feature" data as it is
simpler to implement.

Let's see another example.

------------------
Report[buf]: (6 bytes) => 06 64 93 04 00 00
Path: UPS.PowerSummary.RunTimeToEmpty, Type: Input, ReportID: 0x06, Offset: 8, Size: 32, Value: 1171
------------------

This is the reportID 0x06, in which we have at offset 8 (bits, so the third byte
of the frame after the reportID byte and the 8 first data bits) 32 bits of data
(4 bytes) with a value of 1171 (0x00000493).


3) Sample code

This example illustrate the retrieving of the power status, that is to say if
the device is operating on battery or from line power.

------------------

#include <stdio.h>
#include <usb.h>	/* libusb header file */

#define EATON_MGE_VENDORID		0x0463

int main()
{
	unsigned char buf[20];
	struct usb_device *dev;
	struct usb_bus *bus;
	usb_dev_handle *usbdev;
	int ret, reportId;

	/* libusb base init */
	usb_init();
	usb_find_busses();
	usb_find_devices();

	/* Enumerate USB busses to find the right device */
	for (bus = usb_busses; bus; bus = bus->next) {
		for (dev = bus->devices; dev; dev = dev->next) {

			if (dev->descriptor.idVendor == EATON_MGE_VENDORID) {
				/* You may also want to check the device identifier using
					dev->descriptor.idProduct */

				printf("USB UPS found\n");

				/* Now open the device */
				usbdev = usb_open(dev);

				/* And claim the first interface.
				This may need several tries, and (for Linux) a call to
				usb_detach_kernel_driver_np()
				to replace the Integrated power management */

#ifdef WIN32
                                usb_set_configuration(usbdev,1);
#endif

				usb_claim_interface(usbdev, 0);

				/* Send a request to get UPS.PowerSummary.PresentStatus.ACPresent */
				reportId = 1;
				ret = usb_control_msg(usbdev,
					USB_ENDPOINT_IN + USB_TYPE_CLASS + USB_RECIP_INTERFACE,
					0x01, /* HID_REPORT_GET */
					reportId+(0x03<<8), /* HID_REPORT_TYPE_FEATURE */
					0, buf, 128, /* ask for a large ReportSize */
					5000); /* 5 seconds timeout */ 

				printf("Received %i bytes\n");

				/* Now process the answer, and get the power status */
				if (ret > 0) {
					/* Data bit extraction logic :
					/* First byte of report is report ID:
					   Bit = bufOffset + 8; */
					/* Offset: 0, Size: 1 (in bit(s)) */
					/* Buf[Bit >> 3] & (1 << (Bit & 7)); */
					if ((buf[1] >> 0 & 01) == 1)
						printf("UPS is online\n");
					else
						printf("UPS is on battery\n");
				}
			}
		}
	}
	exit (EXIT_SUCCESS);
}
------------------

NOTE: in order to execute this program, you will need to have proper permissions
to access the device. Either run it as 'root', or preferably use udev (on Linux)
or equivalent system to set the proper rights to access the device.

Compile with 'gcc testusb.c -lusb'... +
Test by running the program, a first time with AC present:

$ sudo ./a.out +
USB UPS found +
Received 4 bytes +
UPS is online +

Then a second time after having removed the main power:

$ sudo ./a.out +
USB UPS found +
Received 4 bytes +
UPS is on battery +


NOTE:  Another approach to communicate directly with USB devices is to use
convenient HID library such link:http://www.signal11.us/oss/hidapi/[hidapi].


4) SHUT implementation

For SHUT reimplementation, you may have a look in the
link:http://old.networkupstools.org/protocols/mge/[Simplified SHUT protocol]
document.

You should also have a look at
link:http://alioth.debian.org/scm/browser.php?group_id=30602[libshut.c] file for
a reference implementation.

XCP
---

XCP protocol specifications are on line
link:http://old.networkupstools.org/protocols/eaton/[here].

You can find a reference implementation in the NUT source tree in
link:http://alioth.debian.org/scm/browser.php?group_id=30602[bcmxcp* files].

SNMP
----

You can find useful lookup table in the NUT source tree in
link:http://alioth.debian.org/scm/browser.php?group_id=30602[*-mib.c files].


[[nut-names]]
Appendix A: NUT command and variable naming scheme
==================================================

include::nut-names.txt[]

